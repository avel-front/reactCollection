# Как устроен Redux  

## Общие положения

Главная особенность Redux заключается в том, что он предлагает изменять state ненапрямую, а опосредованно через вызов action.  

```
store.dispatch(  {type: 'INCREMENT'}  )
```  

В отличии от Flux, Redux работает не с генераторами, а с чистыми функциями. Соответственно пишется чистая функция reducer, чтобы решить, каким образом каждый action преобразует state приложения. Вернуть нужно новый объект.

```
function foo(action, type) {}
```

Нечистые reducer'ы формально будут обработаны, но строго не рекомендуется!  
  
## Краткий разбор  

```
import {createStore} from 'redux'


export function counter(state = 0, action) {
    switch (action.type) {
        case 'INCREMENT':
            return state + 1
        case 'DECREMENT':
            return state - 1
        default:
            return state
    }
}
```

Редюсеры — это просто чистые функции, которые берут предыдущий state и action и возвращают новый state.  
Нельзя изменять объект state напрямую. Если state изменился, нужно возвращать новый объект.  
State может быть примитивом, массивом, объектом или структурой данных.

Когда приложение разрастается, большой reducer разбивается на мелкие reducer'ы через combineReducers.
Можно контролировать их порядок, отправлять дополнительные данные и переиспользовать их.


```
let store = createStore(counter)
```  
  
    
Это store, который хранит состояние приложения.
API: subscribe, dispatch, getState.


```
store.subscribe(() =>
    console.log(store.getState())
)
```

 Метод, который отвечает за обновление UI при изменении состояния.  
 Не рекомендуется использовать метод напрямую, лучше React-Redux.

```
store.dispatch({type: 'INCREMENT'})
store.dispatch({type: 'INCREMENT'})
store.dispatch({type: 'DECREMENT'})
```


Вызов action - единственный способ изменить внутренний state.  


## Три принципа работы  

1. Единственный источник, то есть state всего приложения хранится в дереве объектов внутри одного store.  

2. Единственный способ изменить state - применить action, то есть объект, который описывает, что случится.  

3. Для определения того, как дерево state будет изменено action'ами, используют чистые reducer'ы.


## Структура  

Action'ы - это простые объекты, которые имеют специальное поле (type, payload, error, meta). Они являются единственным источником информации для store, поскольку передаются в него через dispatch.  


```
store.dispatch(  {type: 'INCREMENT'}  )
```  
  
Хранить action'ы лучше в actionTypes.js. Импортировать можно так:  

```
import { ADD_TODO, REMOVE_TODO } from '../actionTypes'
```


### Специальные поля:  

- `type`  
Обязательное поле. Значение - обычно строковая константа. Поле указывает на тип исполняемого action.

- `payload`  
Необязательное поле. Значение - все типы данных. Подойдет любая информация, которая не относятся к `type` и не связана со статусом action.  

- `error`  
Необязательное поле. Значения - true, false, null, undefined. Если true, то ошибка, аналогично rejected promise. Если другое значение, то действие не должно интерпретироваться, как ошибка. Является частью payload.

- `meta`  
Необязательное поле. Значение - все типы данных. Для хранения дополнительной информации, не является частью payload.
